/*
如果把一個數值型別的變數賦值給一個數值型別的變數，且兩者的型別不同，則賦值過程中會發生"隱式"類型轉換(imlicit type conversion)，最後會變成變量的型別。

*/

/*
強制類型轉換

如果想要把一個數值型別的變數賦值給另一個數值型別的變數，且兩者的型別不同，可以使用強制類型轉換(cast)。

強制類型轉換的語法如下：

- C風格：(type) expression


其中，type是要轉換的型別，expression是要轉換的表達式。

強制類型轉換的注意事項：

- 強制類型轉換可以將一個數值型別的變數轉換為另一個數值型別的變數，但是不能將一個變數轉換為一個不相關的型別。
- 強制類型轉換可以將一個較大的數值型別的變數轉換為一個較小的數值型別的變數，但是可能會造成數值的溢位。
- 強制類型轉換可以將一個較小的數值型別的變數轉換為一個較大的數值型別的變數，但是可能會造成數值的精度丟失。
- 強制類型轉換可以將一個浮點數轉換為一個整數，但是小數部分會被"捨棄"。
- 強制類型轉換可以將一個整數轉換為一個浮點數，但是小數部分會被"補0"。
- 強制類型轉換可以將一個布爾值轉換為一個數值型別的變數，true會被轉換為1，false會被轉換為0。
- 強制類型轉換可以將一個數值型別的變數轉換為一個布爾值，非0的數值會被轉換為true，0會被轉換為false。

- C++風格：static_cast<type> (expression)
- C++風格：type(expression)


*/

#include <iostream>
using namespace std;

int main()
{
    bool a = 10; //只要是非0的數值，都會被轉換為true
    short b = false; //false會被轉換為0
    int c = 10.5; //浮點數會被轉換為整數，小數部分會被"捨棄"
    float d = 10; //整數會被轉換為浮點數，小數部分會被"補0"

    unsigned short e = 65536; //超過範圍會溢位

    cout << "a: " << a << endl;
    cout << "b: " << b << endl;
    cout << "c: " << c << endl;
    cout << "d: " << d << endl;
    cout << "e: " << e << endl;

    // 強制類型轉換
    cout << "C風格 a: " << (float)a << endl;
    cout << "C++風格 b: " << static_cast<int>(b) << endl;
    cout << "C++風格 c: " << (int)c << endl;

    cin.get();
    return 0;
}

