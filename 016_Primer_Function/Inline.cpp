/*
inline 修飾符 (c++)

在c中沒有inline這個關鍵字，通常都是使用#define來定義宏來實現內聯函數的功能，但是宏的缺點是不會進行類型檢查，而且嚴格來說宏不是一個函數，而是一種文本替換機制，
所以功能也不好實現。

inline 修飾符用於函數定義時，表示該函數是內聯函數，內聯函數是一種特殊的函數，它的調用可以像宏一樣展開，而不是像普通函數一樣進行函數調用。
可以這樣去理解，呼叫函數的函數其實是存放在一個stack中，當呼叫函數時，會將函數的參數放入stack中，然後跳到函數的位置執行，當函數執行完畢後，會將stack中的參數清除，然後返回到呼叫函數的位置繼續執行。
大量呼叫小函數中的小函數不僅會導致stack中的參數過多，而且會導致程序的效率降低，因為函數的調用是需要時間的，所以為了提高程序的效率，可以使用內聯函數。

宏是什麼?
宏是一種在編譯時進行文本替換的機制，它不是一個函數，而是一種文本替換機制，宏的調用是在編譯時進行的，而不是在運行時進行的。
在台灣宏就是指的巨集，巨集是一種在編譯時進行文本替換的機制，它不是一個函數，而是一種文本替換機制，巨集的調用是在編譯時進行的，而不是在運行時進行的。


甚麼時候適合使用內聯函數?
- 適合

- 不適合
*/

#include <iostream>
using namespace std;

// 定義一個內聯函數
inline int Max(int a, int b)
{
    return a > b ? a : b;
}

int main()
{
    int a = 10;
    int b = 20;

    cout << "Max is " << Max(a, b) << endl;

    return 0;
}

